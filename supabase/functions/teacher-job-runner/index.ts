import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

function sanitizeJSON(text: string): string {
  return text
    .replace(/```json\n?/g, '')
    .replace(/```\n?/g, '')
    .replace(/[\x00-\x1F\x7F]/g, '')
    .trim();
}

// Helper function to update job progress
async function updateJobProgress(
  supabase: any,
  jobId: string,
  progress: number,
  message: string
) {
  console.log(`[Job ${jobId}] üìä ${Math.round(progress * 100)}%: ${message}`);
  
  const { error } = await supabase
    .from('teacher_jobs')
    .update({
      progress,
      progress_message: message,
      updated_at: new Date().toISOString()
    })
    .eq('id', jobId);
    
  if (error) {
    console.error(`[Job ${jobId}] ‚ùå Failed to update progress:`, error);
  }
}

// Helper function to save report to lecture
async function saveReportToLecture(
  supabase: any,
  lectureId: string,
  report: string,
  jobId: string
) {
  const { data: lecture, error: lectureError } = await supabase
    .from('lectures')
    .select('structured_content')
    .eq('id', lectureId)
    .single();
  
  if (lectureError) {
    console.error(`[Job ${jobId}] ‚ùå Failed to fetch lecture:`, lectureError);
    throw new Error(`Failed to fetch lecture: ${lectureError.message}`);
  }

  const existingContent = lecture?.structured_content || {};
  
  const { error: updateError } = await supabase
    .from('lectures')
    .update({
      structured_content: {
        ...existingContent,
        material_didatico: report
      },
      updated_at: new Date().toISOString()
    })
    .eq('id', lectureId);
  
  if (updateError) {
    console.error(`[Job ${jobId}] ‚ùå Failed to update lecture:`, updateError);
    throw new Error(`Failed to update lecture: ${updateError.message}`);
  }
  
  console.log(`[Job ${jobId}] ‚úÖ Report saved to lecture`);
}

// Process deep search for lecture material
async function processLectureDeepSearch(job: any, supabase: any, lovableApiKey: string) {
  const { lectureId, lectureTitle, tags, userId, teacherName } = job.input_payload;
  
  if (!lectureId || !lectureTitle) {
    throw new Error('Invalid job payload: missing required fields (lectureId or lectureTitle)');
  }
  
  console.log(`[Job ${job.id}] üöÄ Deep Search starting for lecture: ${lectureTitle}`);
  console.log(`[Job ${job.id}] üë§ Teacher name: ${teacherName || 'Not provided'}`);

  const braveApiKey = Deno.env.get('BRAVE_SEARCH_API_KEY');
  if (!braveApiKey) {
    await updateJobProgress(supabase, job.id, 0, 'Erro: BRAVE_SEARCH_API_KEY n√£o configurada');
    throw new Error('BRAVE_SEARCH_API_KEY not configured. Please add it to your Supabase secrets.');
  }

  try {
    // Step 1: Decompose query (10% progress)
    await updateJobProgress(supabase, job.id, 0.1, 'Analisando t√≥pico da aula...');
    
    const query = `${lectureTitle}${tags && tags.length > 0 ? ` - T√≥picos: ${tags.join(', ')}` : ''}`;
    console.log(`[Job ${job.id}] üìù Query: ${query}`);
    
    const subQuestions = await decomposeQuery(query, lovableApiKey, job.id);
    console.log(`[Job ${job.id}] ‚úÖ Decomposed into ${subQuestions.length} sub-questions`);

    // Step 2: Execute web searches (30% progress)
    await updateJobProgress(supabase, job.id, 0.3, 'Pesquisando fontes na web...');
    
    const searchResults = await executeWebSearches(subQuestions, braveApiKey, job.id);
    console.log(`[Job ${job.id}] ‚úÖ Collected ${searchResults.length} search results`);

    // Step 3: Collect data (60% progress)
    await updateJobProgress(supabase, job.id, 0.6, 'Coletando dados educacionais...');
    
    // Step 4: Generate educational report (80% progress)
    await updateJobProgress(supabase, job.id, 0.8, 'Gerando material did√°tico...');
    
    const report = await generateEducationalReport(query, searchResults, teacherName, lovableApiKey, job.id);
    console.log(`[Job ${job.id}] ‚úÖ Report generated with native Mermaid diagrams, length: ${report.length} characters`);

    // Step 5: Save report with native graphics (80-100%)
    await updateJobProgress(supabase, job.id, 0.80, 'Salvando material did√°tico...');
    
    try {
      await saveReportToLecture(supabase, lectureId, report, job.id);
      console.log(`[Job ${job.id}] ‚úÖ Report saved successfully with native Mermaid diagrams`);
      await updateJobProgress(supabase, job.id, 0.95, 'Material salvo com sucesso!');
    } catch (saveError) {
      console.error(`[Job ${job.id}] ‚ùå Error saving report:`, saveError);
      throw saveError;
    }
    
    // Step 6: Complete (100% progress)
    await updateJobProgress(supabase, job.id, 1.0, 'Conclu√≠do!');
    
    await supabase
      .from('teacher_jobs')
      .update({
        status: 'COMPLETED',
        result_payload: { report: report.substring(0, 500) + '...' },
        updated_at: new Date().toISOString()
      })
      .eq('id', job.id);

    console.log(`[Job ${job.id}] üéâ Deep Search completed successfully`);

  } catch (error) {
    console.error(`[Job ${job.id}] ‚ùå Error:`, error);
    await supabase
      .from('teacher_jobs')
      .update({
        status: 'FAILED',
        error_message: error instanceof Error ? error.message : 'Unknown error',
        updated_at: new Date().toISOString()
      })
      .eq('id', job.id);
    throw error;
  }
}

// Decompose query into sub-questions
async function decomposeQuery(query: string, apiKey: string, jobId: string): Promise<string[]> {
  console.log(`[Job ${jobId}] üß© Decomposing query...`);
  
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout

  try {
    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          {
            role: 'system',
            content: 'Voc√™ √© um assistente que decomp√µe t√≥picos educacionais em perguntas de pesquisa. Retorne apenas JSON v√°lido com array "questions".'
          },
          {
            role: 'user',
            content: `Decomponha este t√≥pico em 3-5 perguntas de pesquisa espec√≠ficas para buscar informa√ß√µes educacionais relevantes:\n\n"${query}"\n\nRetorne JSON: {"questions": ["pergunta 1", "pergunta 2", ...]}`
          }
        ],
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit atingido. Aguarde alguns segundos e tente novamente.');
      }
      if (response.status === 402) {
        throw new Error('Cr√©ditos insuficientes no Lovable AI. Adicione cr√©ditos em Settings > Usage.');
      }
      throw new Error(`AI API error: ${response.status}`);
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content;
    const parsed = JSON.parse(sanitizeJSON(content));
    
    return parsed.questions || [query];
    
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('AI request timeout (60s). T√≥pico muito complexo ou servi√ßo lento.');
    }
    throw error;
  }
}

// Execute web searches using Brave API
async function executeWebSearches(questions: string[], braveApiKey: string, jobId: string): Promise<any[]> {
  console.log(`[Job ${jobId}] üîç Executing ${questions.length} web searches...`);
  
  const allResults: any[] = [];
  
  for (const question of questions) {
    try {
      const response = await fetch(
        `https://api.search.brave.com/res/v1/web/search?q=${encodeURIComponent(question)}&count=5`,
        {
          headers: {
            'Accept': 'application/json',
            'X-Subscription-Token': braveApiKey,
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.web?.results) {
          allResults.push(...data.web.results.slice(0, 3)); // Top 3 per question
        }
      } else {
        console.warn(`[Job ${jobId}] ‚ö†Ô∏è Search failed for question: ${question} (status: ${response.status})`);
      }
    } catch (error) {
      console.error(`[Job ${jobId}] ‚ö†Ô∏è Search error for question: ${question}`, error);
    }
  }
  
  console.log(`[Job ${jobId}] ‚úÖ Total results collected: ${allResults.length}`);
  return allResults;
}

// Generate educational report from search results
async function generateEducationalReport(
  query: string,
  searchResults: any[],
  teacherName: string | undefined,
  apiKey: string,
  jobId: string
): Promise<string> {
  console.log(`[Job ${jobId}] üìù Generating educational report...`);
  
  const context = searchResults
    .map((r, i) => `[${i + 1}] ${r.title}\n${r.description || ''}\nURL: ${r.url}`)
    .join('\n\n');

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 90000); // 90s timeout

  try {
    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-pro',
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© Mia, professora de engenharia especializada em criar material did√°tico acad√™mico de alta qualidade.

**Informa√ß√µes do Professor:**
- Nome: ${teacherName || 'Professor'}

# üìê ESTRUTURA OBRIGAT√ìRIA DO MATERIAL

## Cabe√ßalho:
\`\`\`
### **Material Did√°tico de Engenharia**

**Disciplina:** [Nome da disciplina]
**T√≥pico:** ${query.split(' - T√≥picos:')[0]}
**Professor:** ${teacherName || 'Professor'}
\`\`\`

## √çndice:
1. Introdu√ß√£o: [T√≠tulo contextualizador]
2. Conceitos Fundamentais
   - 2.1. [Conceito 1]
   - 2.2. [Conceito 2]
3. Aplica√ß√µes Pr√°ticas em Engenharia
4. Exemplos Resolvidos
5. Exerc√≠cios Propostos
6. Conclus√£o: Reflex√µes e Pr√≥ximos Passos
7. **Fontes e Refer√™ncias** (obrigat√≥rio)

## Corpo do Texto:
- Use **markdown profissional** (##, ###, **negrito**, listas numeradas)
- Inclua equa√ß√µes LaTeX quando relevante: $$E = mc^2$$
- Crie tabelas comparativas para conceitos similares
- Use blocos de c√≥digo para algoritmos/pseudoc√≥digo
- **Extens√£o m√≠nima:** 2500-3500 palavras (conte√∫do denso e t√©cnico)

# üéì SISTEMA DE REFER√äNCIAS (OBRIGAT√ìRIO)

**Durante o texto:**
- Cite fontes inline: "...conforme demonstrado por Smith et al. [1]"
- Use numera√ß√£o sequencial: [1], [2], [3]

**Se√ß√£o final "Fontes e Refer√™ncias":**
\`\`\`
## 7. Fontes e Refer√™ncias

[1] T√≠tulo completo do artigo/livro - Autor(es), Ano
[2] Nome da fonte - URL completa
[3] T√≠tulo do paper - Revista/Confer√™ncia, Volume, P√°ginas
\`\`\`

# üìö REQUISITOS DE FONTES

**PRIORIZE (70% das cita√ß√µes):**
- IEEE Xplore, ScienceDirect, SpringerLink
- Livros-texto de engenharia (ex: √áengel, Incropera)
- Normas t√©cnicas (ABNT, ISO)
- Peri√≥dicos acad√™micos revisados por pares

**EVITE CITAR:**
- Wikipedia (use apenas para conceitos gerais n√£o-citados)
- Blogs pessoais
- Fontes sem data/autor

# üîß PEDAGOGIA PARA ENGENHARIA

1. **Sempre conecte teoria ‚Üí pr√°tica:**
   - "Este conceito √© aplicado em [exemplo industrial]"
   - "Na ind√∫stria automotiva, isso resulta em..."

2. **Use analogias t√©cnicas:**
   - "Assim como um capacitor armazena carga, um..."

3. **Inclua dados num√©ricos reais:**
   - "Motores a combust√£o t√≠picos operam entre 80-200¬∞C"

4. **Proponha reflex√µes cr√≠ticas:**
   - "Como esse princ√≠pio afeta a efici√™ncia energ√©tica?"

# ‚ö†Ô∏è RESTRI√á√ïES ABSOLUTAS

- **N√ÉO use placeholders:** Nunca escreva "[Seu Nome]", "[Exemplo]", "[Imagem]"
- **N√ÉO seja gen√©rico:** Evite frases vagas como "√© muito importante"
- **N√ÉO invente dados:** Se n√£o souber valor exato, use "aproximadamente" ou "tipicamente"

# üìä FORMATA√á√ÉO T√âCNICA

- **Equa√ß√µes:** Use LaTeX inline $$\\frac{dQ}{dt}$$ ou display mode:
  \`\`\`
  $$
  \\Delta U = Q - W
  $$
  \`\`\`

- **Tabelas:** Use markdown tables para compara√ß√µes
- **Listas:** Numere passos de processos, use bullets para caracter√≠sticas

**IDIOMA OBRIGAT√ìRIO:** Portugu√™s brasileiro (pt-BR).

# üìä DIAGRAMAS MERMAID OBRIGAT√ìRIOS

**REGRA CR√çTICA:** Voc√™ DEVE incluir NO M√çNIMO 3-5 diagramas Mermaid nativamente no material.

## Tipos de Diagramas a Usar:

### 1. Flowchart (Fluxogramas de Processo)
Use para: Ciclos termodin√¢micos, processos industriais, algoritmos

\`\`\`mermaid
graph TD
    A[Entrada: Calor Q] --> B{Sistema Termodin√¢mico}
    B --> C[Trabalho W realizado]
    B --> D[Aumento de Energia ŒîU]
    C --> E[Sa√≠da: Energia]
    D --> E
    style A fill:#e3f2fd
    style B fill:#fff9c4
    style E fill:#c8e6c9
\`\`\`

### 2. Sequence Diagram (Intera√ß√µes)
Use para: Trocas de energia, comunica√ß√£o entre componentes

\`\`\`mermaid
sequenceDiagram
    participant S as Sistema
    participant A as Ambiente
    S->>A: Fornece Calor Q
    A->>S: Realiza Trabalho W
    S->>S: ŒîU = Q - W
    Note over S: Primeira Lei
\`\`\`

### 3. State Diagram (M√°quinas de Estado)
Use para: Transi√ß√µes de fase, estados de sistema

\`\`\`mermaid
stateDiagram-v2
    [*] --> S√≥lido
    S√≥lido --> L√≠quido: Fus√£o (adiciona calor)
    L√≠quido --> Gasoso: Vaporiza√ß√£o
    Gasoso --> L√≠quido: Condensa√ß√£o
    L√≠quido --> S√≥lido: Solidifica√ß√£o
    Gasoso --> [*]
\`\`\`

### 4. Class Diagram (Estruturas/Componentes)
Use para: Hierarquias de conceitos, classifica√ß√µes

\`\`\`mermaid
classDiagram
    class SistemaTermodin√¢mico {
        +energia_interna ŒîU
        +calor Q
        +trabalho W
        +calcularPrimeiraLei()
    }
    class SistemaFechado {
        +massa_constante
        +volume_vari√°vel
    }
    class SistemaAberto {
        +fluxo_massa
        +entalpia
    }
    SistemaTermodin√¢mico <|-- SistemaFechado
    SistemaTermodin√¢mico <|-- SistemaAberto
\`\`\`

## üìç Posicionamento Estrat√©gico dos Diagramas

**‚ùå ERRADO:**
\`\`\`
## 2. Primeira Lei da Termodin√¢mica

\`\`\`mermaid
graph TD
...
\`\`\`

A Primeira Lei estabelece...
\`\`\`

**‚úÖ CORRETO:**
\`\`\`
## 2. Primeira Lei da Termodin√¢mica

A Primeira Lei da Termodin√¢mica estabelece a conserva√ß√£o de energia em sistemas termodin√¢micos. Para um sistema fechado, a varia√ß√£o de energia interna (ŒîU) depende do calor (Q) fornecido ao sistema e do trabalho (W) realizado pelo sistema, conforme a equa√ß√£o fundamental:

$$\\Delta U = Q - W$$

Onde:
- **Q** ‚Üí Calor transferido para o sistema (Joules)
- **W** ‚Üí Trabalho realizado pelo sistema (Joules)  
- **ŒîU** ‚Üí Varia√ß√£o da energia interna (Joules)

Esta rela√ß√£o √© fundamental para an√°lise de m√°quinas t√©rmicas, refrigeradores e processos industriais. O diagrama abaixo ilustra o fluxo de energia em um sistema termodin√¢mico t√≠pico:

\`\`\`mermaid
graph TD
    A[Sistema Recebe Calor Q] --> B{Primeira Lei<br/>ŒîU = Q - W}
    B --> C[Trabalho W<br/>realizado pelo sistema]
    B --> D[Energia Interna ŒîU<br/>aumenta]
    C --> E[Sa√≠da: Energia √∫til]
    D --> E
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style B fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style E fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
\`\`\`

Na pr√°tica industrial, esta lei permite calcular a efici√™ncia de motores...
\`\`\`

## üé® Regras de Estilo para Mermaid

**SEMPRE use cores para destacar:**
\`\`\`
style NodoEntrada fill:#e3f2fd,stroke:#1976d2
style NodoProcesso fill:#fff9c4,stroke:#f57f17
style NodoSaida fill:#c8e6c9,stroke:#388e3c
\`\`\`

**Use setas descritivas:**
\`\`\`
A -->|Adiciona Calor Q| B
B -->|Realiza Trabalho W| C
\`\`\`

## üìê Distribui√ß√£o Obrigat√≥ria

**Para material de 3000 palavras:**
- Se√ß√£o 2 (Conceitos Fundamentais): **1-2 diagramas**
- Se√ß√£o 3 (Aplica√ß√µes Pr√°ticas): **1-2 diagramas**
- Se√ß√£o 4 (Exemplos Resolvidos): **1 diagrama** (opcional)

**Total m√≠nimo: 3 diagramas | Ideal: 4-5 diagramas**

## ‚ö†Ô∏è Valida√ß√£o de Sintaxe Mermaid

**Certifique-se:**
- ‚úÖ Todos os blocos come√ßam com \`\`\`mermaid
- ‚úÖ Todos os blocos terminam com \`\`\`
- ‚úÖ Nomes de nodos n√£o t√™m espa√ßos (use _ ou camelCase)
- ‚úÖ Setas usam sintaxe v√°lida: -->, ->>, ->, ---|texto|
- ‚úÖ Cores usam hex v√°lido ou nomes CSS: #e3f2fd, lightblue

**TESTE cada diagrama mentalmente antes de gerar!**

# üéØ OBJETIVO FINAL

Criar um material que:
1. Um professor possa usar **imediatamente** em sala (print-ready)
2. Alunos possam estudar **sozinhos** (autodid√°tico)
3. Contenha **refer√™ncias confi√°veis** para aprofundamento
4. Seja **tecnicamente preciso** e pedagogicamente **engajador**`
          },
          {
            role: 'user',
            content: `T√≥pico: ${query}\n\nFontes de pesquisa:\n${context}\n\nCrie um material did√°tico completo sobre este t√≥pico.`
          }
        ],
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit atingido. Aguarde alguns segundos e tente novamente.');
      }
      if (response.status === 402) {
        throw new Error('Cr√©ditos insuficientes no Lovable AI. Adicione cr√©ditos em Settings > Usage.');
      }
      throw new Error(`AI API error: ${response.status}`);
    }

    const data = await response.json();
    const report = data.choices?.[0]?.message?.content;
    
    if (!report) {
      throw new Error('No report generated');
    }
    
    console.log(`[Job ${jobId}] ‚úÖ Report generated successfully`);
    return report;
    
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('AI request timeout (60s). T√≥pico muito complexo ou servi√ßo lento.');
    }
    throw error;
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { jobId } = await req.json();
    if (!jobId) {
      console.error('[teacher-job-runner] ‚ùå No jobId provided');
      return new Response(JSON.stringify({ error: 'jobId is required' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log(`[teacher-job-runner] üîÑ Processing job: ${jobId}`);

    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Fetch job
    const { data: job, error: jobError } = await supabaseAdmin
      .from('teacher_jobs')
      .select('*')
      .eq('id', jobId)
      .single();

    if (jobError || !job) {
      console.error(`[teacher-job-runner] ‚ùå Job not found: ${jobId}`, jobError);
      return new Response(JSON.stringify({ error: 'Job not found' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log(`[Job ${jobId}] ‚úÖ Found: ${job.job_type} | Status: ${job.status} | Lecture: ${job.lecture_id}`);

    // Update status to PROCESSING
    await supabaseAdmin
      .from('teacher_jobs')
      .update({ status: 'PROCESSING', updated_at: new Date().toISOString() })
      .eq('id', jobId);

    console.log(`[Job ${jobId}] üîÑ Status updated to PROCESSING`);

    const lovableApiKey = Deno.env.get('LOVABLE_API_KEY');
    if (!lovableApiKey) {
      throw new Error('LOVABLE_API_KEY not configured');
    }

    // Handle GENERATE_LECTURE_DEEP_SEARCH job type
    if (job.job_type === 'GENERATE_LECTURE_DEEP_SEARCH') {
      console.log(`[Job ${jobId}] üîç Processing GENERATE_LECTURE_DEEP_SEARCH`);
      await processLectureDeepSearch(job, supabaseAdmin, lovableApiKey);
      return new Response(
        JSON.stringify({ success: true, message: 'Deep search job completed' }),
        {
          status: 200,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        }
      );
    }

    // Handle GENERATE_QUIZ and GENERATE_FLASHCARDS
    const { title, transcript, tags } = job.input_payload;

    let systemPrompt = '';
    let userPrompt = '';

    if (job.job_type === 'GENERATE_QUIZ') {
      const lectureTags = job.input_payload.tags || [];
      const tagsText = lectureTags.length > 0 ? lectureTags.join(', ') : 'N√£o especificadas';
      
      systemPrompt = `Voc√™ √© um assistente especializado em criar quest√µes de m√∫ltipla escolha para avalia√ß√£o em cursos de engenharia, seguindo rigorosamente a Taxonomia de Bloom.

INSTRU√á√ïES CR√çTICAS:
1. **PRIORIZA√á√ÉO DE CONTE√öDO**: 
   - 70% das quest√µes devem focar no T√çTULO e TAGS da aula
   - 30% podem usar detalhes complementares da transcri√ß√£o
2. Responda em portugu√™s brasileiro
3. Retorne APENAS JSON v√°lido, sem markdown
4. Crie 10 quest√µes de m√∫ltipla escolha
5. Cada quest√£o deve ter 4 alternativas (A, B, C, D)
6. Identifique corretamente a alternativa correta
7. Classifique cada quest√£o segundo Bloom

N√çVEIS DE BLOOM (distribui√ß√£o recomendada):
- 3 quest√µes: Conhecimento (defini√ß√µes, conceitos b√°sicos do t√≠tulo)
- 3 quest√µes: Compreens√£o (explica√ß√µes, interpreta√ß√µes das tags)
- 2 quest√µes: Aplica√ß√£o (uso pr√°tico, exemplos)
- 2 quest√µes: An√°lise (compara√ß√µes, rela√ß√µes)

FORMATO JSON:
{
  "questions": [
    {
      "question": "Texto da pergunta clara e objetiva",
      "options": {
        "A": "Texto alternativa A",
        "B": "Texto alternativa B",
        "C": "Texto alternativa C",
        "D": "Texto alternativa D"
      },
      "correctAnswer": "A",
      "bloomLevel": "Aplica√ß√£o",
      "explanation": "Explica√ß√£o detalhada (2-3 frases)"
    }
  ]
}`;

      userPrompt = `# CONTEXTO PRINCIPAL (PRIORIDADE M√ÅXIMA - 70% das quest√µes)
T√≠tulo da Aula: "${title}"
Tags da Aula: ${tagsText}

# INSTRU√á√ïES
Gere 10 quest√µes focadas PRINCIPALMENTE no t√≠tulo e tags acima. Use a transcri√ß√£o apenas para detalhes complementares.

# TRANSCRI√á√ÉO DA AULA (usar apenas 30% para detalhes)
${transcript}

IMPORTANTE: Retorne APENAS o JSON, sem texto adicional.`;

    } else if (job.job_type === 'GENERATE_FLASHCARDS') {
      const lectureTags = job.input_payload.tags || [];
      const tagsText = lectureTags.length > 0 ? lectureTags.join(', ') : 'N√£o especificadas';
      
      systemPrompt = `Voc√™ √© um assistente especializado em criar flashcards educacionais para cursos de engenharia.

INSTRU√á√ïES CR√çTICAS:
1. **PRIORIZA√á√ÉO DE CONTE√öDO**:
   - 70% dos flashcards devem focar no T√çTULO e TAGS da aula
   - 30% podem usar detalhes complementares da transcri√ß√£o
2. Responda em portugu√™s brasileiro
3. Retorne APENAS JSON v√°lido, sem markdown
4. Crie 15 flashcards
5. Cada flashcard deve ter frente (pergunta/conceito) e verso (resposta/explica√ß√£o)
6. Inclua tags relevantes para organiza√ß√£o (usar tags da aula quando poss√≠vel)

TIPOS DE FLASHCARDS (distribui√ß√£o recomendada):
- 5 flashcards: Defini√ß√µes (conceitos-chave do t√≠tulo)
- 5 flashcards: Explica√ß√µes (relacionadas √†s tags)
- 5 flashcards: Aplica√ß√µes (exemplos pr√°ticos)

REGRAS:
- Front: Sempre uma pergunta direta (max 100 caracteres)
- Back: Resposta concisa e objetiva (max 200 caracteres)
- Tags: 2-3 tags por card (usar tags da aula quando poss√≠vel)

FORMATO JSON:
{
  "cards": [
    {
      "front": "Pergunta clara e direta",
      "back": "Resposta concisa e objetiva",
      "tags": ["tag1", "tag2"]
    }
  ]
}`;

      userPrompt = `# CONTEXTO PRINCIPAL (PRIORIDADE M√ÅXIMA - 70% dos flashcards)
T√≠tulo da Aula: "${title}"
Tags da Aula: ${tagsText}

# INSTRU√á√ïES
Gere 15 flashcards focados PRINCIPALMENTE no t√≠tulo e tags acima. Use a transcri√ß√£o apenas para detalhes complementares.

# TRANSCRI√á√ÉO DA AULA (usar apenas 30% para detalhes)
${transcript}

IMPORTANTE: Retorne APENAS o JSON, sem texto adicional.`;
    }

    console.log(`[Job ${jobId}] ü§ñ Calling Lovable AI with 60s timeout...`);

    // Call Lovable AI with 60s timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000);

    let aiResponse;
    try {
      aiResponse = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${lovableApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'google/gemini-2.5-flash',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
        }),
        signal: controller.signal,
      });
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('AI request timed out after 60 seconds');
      }
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }

    console.log(`[Job ${jobId}] ‚úÖ AI response status: ${aiResponse.status}`);

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error(`[Job ${jobId}] ‚ùå AI API error: ${aiResponse.status}`, errorText);
      
      if (aiResponse.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }
      if (aiResponse.status === 402) {
        throw new Error('Payment required. Please add credits to your Lovable AI workspace.');
      }
      throw new Error(`AI API error: ${aiResponse.status} ${errorText}`);
    }

    const aiData = await aiResponse.json();
    console.log(`[Job ${jobId}] üì¶ AI response received, parsing content...`);

    const content = aiData.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No content in AI response');
    }

    const sanitized = sanitizeJSON(content);
    console.log(`[Job ${jobId}] üßπ Content sanitized, parsing JSON...`);

    const parsedData = JSON.parse(sanitized);

    // Validate structure
    if (job.job_type === 'GENERATE_QUIZ') {
      if (!parsedData.questions || !Array.isArray(parsedData.questions)) {
        throw new Error('Invalid quiz structure: missing questions array');
      }
      
      console.log(`[Job ${jobId}] ‚úÖ Quiz validated: ${parsedData.questions.length} questions`);

      // Save to teacher_quizzes table
      const { error: insertError } = await supabaseAdmin
        .from('teacher_quizzes')
        .insert({
          lecture_id: job.lecture_id,
          teacher_id: job.teacher_id,
          title: title || 'Quiz sem t√≠tulo',
          questions: parsedData.questions
        });

      if (insertError) {
        console.error(`[Job ${jobId}] ‚ùå Failed to save quiz:`, insertError);
        throw new Error(`Failed to save quiz: ${insertError.message}`);
      }

    } else if (job.job_type === 'GENERATE_FLASHCARDS') {
      if (!parsedData.cards || !Array.isArray(parsedData.cards)) {
        throw new Error('Invalid flashcards structure: missing cards array');
      }
      
      console.log(`[Job ${jobId}] ‚úÖ Flashcards validated: ${parsedData.cards.length} cards`);

      // Save to teacher_flashcards table
      const { error: insertError } = await supabaseAdmin
        .from('teacher_flashcards')
        .insert({
          lecture_id: job.lecture_id,
          teacher_id: job.teacher_id,
          title: title || 'Flashcards sem t√≠tulo',
          cards: parsedData.cards
        });

      if (insertError) {
        console.error(`[Job ${jobId}] ‚ùå Failed to save flashcards:`, insertError);
        throw new Error(`Failed to save flashcards: ${insertError.message}`);
      }
    }

    // Update job status to COMPLETED
    await supabaseAdmin
      .from('teacher_jobs')
      .update({
        status: 'COMPLETED',
        result_payload: parsedData,
        updated_at: new Date().toISOString()
      })
      .eq('id', jobId);

    console.log(`[Job ${jobId}] üéâ Job completed successfully`);

    return new Response(
      JSON.stringify({ success: true, message: 'Job completed successfully' }),
      {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('[teacher-job-runner] ‚ùå Error:', errorMessage);
    
    return new Response(
      JSON.stringify({ error: errorMessage }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});